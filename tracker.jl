using SparseArrays

norm_pts(pt_vector,d=2) = sum(abs2,pt_vector,dims=d)

function simpletracker(points, max_linking_distance=Inf,max_gap_closing=3)
# SIMPLETRACKER  a simple particle tracking algorithm that can deal with gaps
#
# *Tracking* , or particle linking, consist in re-building the trajectories
# of one or several particles as they move along time. Their position is
# reported at each frame, but their identiy is yet unknown: we do not know
# what particle in one frame corresponding to a particle in the previous
# frame. Tracking algorithms aim at providing a solution for this problem.
#
# |simpletracker.m| is - as the name says - a simple implementation of a
# tracking algorithm, that can deal with gaps. A gap happens when one
# particle that was detected in one frame is not detected in the subsequent
# one. If not dealt with, this generates a track break, or a gap, in the
# frame where the particule disappear, and a false new track in the frame
# where it re-appear.
#
# |simpletracker| first do a frame-to-frame linking step, where links are
# first created between each frame pair, using by default the hungarian
# algorithm of |hungarianlinker|. Links are created amongst particle paris
# found to be the closest (euclidean distance). By virtue of the hungarian
# algorithm, it is ensured that the sum of the pair distances is minimized
# over all particules between two frames.
#
# Then a second iteration is done through the data, investigating track
# ends. If a track beginning is found close to a track end in a subsequent
# track, a link spanning multiple frame can be created, bridging the gap
# and restoring the track. The gap-closing step uses the nearest neighbor
# algorithm provided by |nearestneighborlinker|.
#
# INPUT SYNTAX
#
# tracks = SIMPLETRACKER(points) rebuilds the tracks generated by the
# particle whose coordinates are in |points|. |points| must be a cell
# array, with one cell per frame considered. Each cell then contains the
# coordinates of the particles found in that frame in the shape of a
# |n_points x n_dim| double array, where |n_points| is the number of points
# in that frame (that can vary a lot from one frame to another) and |n_dim|
# is the dimensionality of the problem (1 for 1D, 2 for 2D, 3 for 3D,
# etc...).
#
# 'MaxLinkingDistance' - a positive number, by default Inifity.
# Defines a maximal distance for particle linking. Two particles will not
# be linked (even if they are the remaining closest pair) if their distance
# is larger than this value. By default, it is infinite, not preventing nay
# linking.
# 
# 'MaxGapClosing' - a positive integer, by default 3
# Defines a maximal frame distance in gap-closing. Frames further way than
# this value will not be investigated for gap closing. By default, it has
# the value of 3.
#
# OUTPUT SYNTAX
#
# track = SIMPLETRACKER(...) return a cell array, with one cell per found
# track. Each track is made of a |n_frames x 1| integer array, containing
# the index of the particle belonging to that track in the corresponding
# frame. NaN values report that for this track at this frame, a particle
# could not be found (gap). 
# 
# Example output: |track{1} = [ 1 2 1 NaN 4 ]| means that the first track
# is made of the particle 1 in the first frame, the particule 2 in the
# second frame, the particle 1 in the 3rd frame, no particle in the 4th
# frame, and the 4th particle in the 5th frame.
#
# [ tracks adjacency_tracks ] = SIMPLETRACKER(...) return also a cell array
# with one cell per track, but the indices in each track are the global
# indices of the concatenated points array, that can be obtained by
# |all_points = vertcat( points{:} );|. It is very useful for plotting
# applications.
#
# [ tracks adjacency_tracks A ] = SIMPLETRACKER(...) return the sparse
# adjacency matrix. This matrix is made everywhere of 0s, expect for links
# between a source particle (row) and a target particle (column) where
# there is a 1. Rows and columns indices are for points in the concatenated
# points array. Only forward links are reported (from a frame to a frame
# later), so this matrix has no non-zero elements in the bottom left
# diagonal half. Reconstructing a crude trajectory using this matrix can be
# as simple as calling |gplot( A, vertcat( points{:} ) )|
# 
# VERSION HISTORY
#
# * v1.0 - November 2011 - Initial release.
# * v1.1 - May 2012 - Solve memory problems for large number of points.
#                   - Considerable speed improvement using properly the
#                   sparse matrices.
#                   - Use the key/value pair syntax to configure the
#                   function.
# * v1.3 - August 2012 - Fix a severe bug thanks to Dave Cade
#
# Jean-Yves Tinevez < jeanyves.tinevez@gmail.com> November 2011 - 2012
        
    n_slices = size(points)[1];
    
    current_slice_index = 0;
    row_indices = Array{Any}(undef,n_slices);
    column_indices = Array{Any}(undef,n_slices);
    unmatched_targets = Array{Any}(undef,n_slices);
    unmatched_sources = Array{Any}(undef,n_slices);
    n_cells=map(c->size(c)[1], points[:])
      
    for i = 1 : n_slices-1       
        source = points[i];
        target = points[i+1];
        target_indices , _, unmatched_targets[i+1] = nearestneighborlinker(source, target, max_linking_distance);
        unmatched_sources[i] = findall( x-> x == -1,target_indices);
        
        # Prepare holders for links in the sparse matrix
        n_links = sum(target_indices .!= -1);
        row_indices[i] = fill(NaN, n_links);
        column_indices[i] = fill(NaN,n_links);
        
        # Put it in the adjacency matrix
        index = 1;
        for j = 1 : size(target_indices,1)          
            # If we did not find a proper target to link, we skip
            if target_indices[j] == -1
                continue
            end            
            # The source line number in the adjacency matrix
            row_indices[i][index] = current_slice_index + j;            
            # The target column number in the adjacency matrix
            column_indices[i][index] = current_slice_index + n_cells[i] + target_indices[j];          
            index = index + 1;         
        end       
        current_slice_index = current_slice_index + n_cells[i];
    end

    # Need to check if this is needed since we already have a matrix, not a cell here
    row_index=Array{Int64}(undef,0);
    column_index=Array{Int64}(undef,0);
    for kk=1:size(row_indices,1)-1
        append!(row_index,convert.(Int64,row_indices[kk]));
        append!(column_index,convert.(Int64,column_indices[kk]));
    end        
    link_flag = ones(Int64,size(row_index,1));
    n_total_cells = sum(n_cells);

    A = sparse(row_index, column_index, link_flag, n_total_cells, n_total_cells);    
    
    ## Gap closing 
    current_slice_index = 0;
    for i = 1 : n_slices-2   
        # Try to find a target in the frames following, starting at i+2, and
        # parsing over the target that are not part in a link already.        
        current_target_slice_index = current_slice_index + n_cells[i] + n_cells[i+1];       
        for j = i + 2 : min(i + max_gap_closing, n_slices)            
            source = points[i][unmatched_sources[i],:];
            target = points[j][unmatched_targets[j],:];            
            if isempty(source) || isempty(target)
                current_target_slice_index = current_target_slice_index + n_cells[j];
                continue
            end            
            target_indices,_,_ = nearestneighborlinker(source, target, max_linking_distance);
            
            # Put it in the adjacency matrix
#            for k = 1 : size(target_indices)[1]
                
                # If we did not find a proper target to link, we skip
#                if target_indices[k] == -1
#                    continue
#                end
                                
                # The source line number in the adjacency matrix
#                row_index = current_slice_index + unmatched_sources[i][k];
                # The target column number in the adjacency matrix
#                column_index = current_target_slice_index + unmatched_targets[j](target_indices[k]);
#                A[row_index, column_index] = 1; ##ok<SPRIX>              
#            end
#            new_links_target =  target_indices .!= -1;
            
            # Make linked sources unavailable for further linking
#            unmatched_sources[i][new_links_target] = [];  
            # Make linked targets unavailable for further linking
#            unmatched_targets[j](target_indices[new_links_target]) = [];           
#            current_target_slice_index = current_target_slice_index + n_cells[j];
        end
#        current_slice_index = current_slice_index + n_cells[i];
    end
    
    ## Parse adjacency matrix to build tracks
    
    # Find columns full of 0s -> means this cell has no source == track
    cells_without_source =findall(x->x==0,vec(sum(A,dims=1)));
    
    n_tracks = size(cells_without_source,1);
    adjacency_tracks = Array{Any}(undef,n_tracks);
    
    AT = transpose(A);
    
    for i = 1 : n_tracks        
        tmp_holder = fill(NaN,n_total_cells);
        target = cells_without_source[i];
        index = 1;
        while target != nothing
            tmp_holder[index] = target;
            target = findfirst(AT[:,target] .== 1);
            index = index + 1;
        end        
        adjacency_tracks[i] = tmp_holder[.!isnan.(tmp_holder)];
    end
    
    ## Reparse adjacency track index to have it right.
    # The trouble with the previous track index is that the index in each
    # track refers to the index in the adjacency matrix, not the point in
    # the original array. We have to reparse it to put it right.
    
    tracks = Array{Any}(undef,n_tracks);    
    for i = 1 : n_tracks      
        adjacency_track = adjacency_tracks[i];
        track = fill(NaN,n_slices);
        for j = 1 : size(adjacency_track,1)            
            cell_index = adjacency_track[j];           
            # We must determine the frame this index belong to
            tmp = cell_index;
            frame_index = 1;
            while tmp > 0
                tmp = tmp - n_cells[frame_index];
                frame_index = frame_index + 1;
            end
            frame_index = frame_index - 1;
            in_frame_cell_index = tmp + n_cells[frame_index];
            track[frame_index] = in_frame_cell_index;
        end        
        tracks[i] = track;
    end  
    return (tracks, adjacency_tracks, A)
end

function nearestneighborlinker(source, target, max_distance=Inf)
#NEARESTNEIGHBORLINKER link two lists of points based on nearest neighbor.
#
# target_indices = NEARESTNEIGHBORLINKER(source, target) finds for each
# point in 'source' the closest point in 'target'. These 2 inputs must be
# arrays with one point per row, and have their cartesian coordinates in
# each column (1D, 2D, 3D, ...). Nearest neighbor matching is based on
# euclidean distance. The two arrays might not have the same number of
# points.
#
# The indices of the 'target' points are returned in an array
# 'target_indices', so that each row in 'source' matches the corresponding
# row in 'target(target_indices, :)'.
#
# The linking is exclusive: one source point is linked to at most one
# target point, and conversely. The linking is only locally optimal: the
# two closest points amongst the two sets are sought for first, then the
# second closest pair, excluding the first, etc... This ensures that the
# resulting linking will not depend on the order of the points in each set.
#
# target_indices = NEARESTNEIGHBORLINKER(source, target, max_distance) adds
# a condition on distance. If the nearest neighbor is found to be at a
# distance larger than the given 'max_distance', they are not linked, and
# the 'target_indices' receive the value -1 for this source point. The same
# happens if all target points are exhausted.
# 
# [ target_indices target_distances ] = 
#                                   NEARESTNEIGHBORLINKER(source, target)
# additionaly return the distance to the matched target point. Un-matched
# source points have a distance value set to NaN.
#
# [ target_indices target_distances unmatched_targets ]= 
#                                   NEARESTNEIGHBORLINKER(source, target)
# additionaly return the indices of the points in 'target' that have not
# been linked.
#
# This is the cheapest (in term of accuracy) algorithm for linking that can
# be made. In particular, it is not guaranteed (and it is generally not the
# case) that the returned linking is an optimum for the sum of distances.
# Each source point is matched regardless of the others, there is no global
# optimization here (the Hungarian algorithm does that). Also, there exists
# refinement to nearest neighbor searches, such as the use of KD-trees;
# this contribution is exempt of such developments.
#
# 
# VERSION HISTORY
#
# * v1.0 - November 2011 - Initial release.
# * v1.1 - May 2012 - Fix a severe bug thanks to Dave Cade
#
# Jean-Yves Tinevez < jeanyves.tinevez@gmail.com> November 2011 - 2012

    n_source_points = size(source, 1);
    n_target_points = size(target, 1);
    println(n_source_points)
    println(n_target_points)
    
    D = fill(NaN, n_source_points, n_target_points);
    
    # Build distance matrix
    for i = 1 : n_source_points
        
        # Pick one source point
        current_point = source[i, :];
        
        # Compute square distance to all target points
        diff_coords = target .- current_point';
        square_dist = norm_pts(diff_coords)';
        
        # Store them
        D[i, :] = square_dist;       
    end
    
    # Deal with maximal linking distance: we simply mark these links as already
    # treated, so that they can never generate a link.
    D[D .> max_distance * max_distance] .= Inf;
        
    target_indices = -1 .* ones(Int32, n_source_points);
    target_distances = fill(NaN, n_source_points, 1);
    
    # Parse distance matrix
    while !all(isinf.(D))
        
        min_D,cart_closest_targets = findmin(D, dims=2); # index of the closest target for each source points
        sorted_index = sortperm(min_D[:,1]);
        closest_targets=map(a->a[2], cart_closest_targets);
        for i = 1 : size(sorted_index)[1]
            
            source_index =  sorted_index[i];
            target_index =  closest_targets[sorted_index[i]];
                        
            # Did we already assigned this target to a source?
            if any( target_index .== target_indices )
                # Yes, then exit the loop and change the distance matrix to
                # prevent this assignment
                break
                
            else
                
                # No, then store this assignment
                target_indices[source_index] = target_index;
                target_distances[source_index] = sqrt( min_D[sorted_index[i]]);
                
                # And make it impossible to find it again by putting the target
                # point to infinity in the distance matrix
                D[:, target_index] .= Inf;
                # And the same for the source line
                D[source_index,:] .= Inf;
                
                if all(isinf.(D))
                    break
                end
                
            end
            
        end
        
    end
    
    unassigned_targets = setdiff( 1:n_target_points , target_indices );
    return (target_indices, target_distances, unassigned_targets)
end

function  FastPeakFind(d)
# Analyze noisy 2D images and find peaks using local maxima (1 pixel
# resolution) or weighted centroids (sub-pixel resolution).
# The code is designed to be as fast as possible, so I kept it pretty basic.
# The code assumes that the peaks are relatively sparse, test whether there
# is too much pile up and set threshold or user defined filter accordingly.
#
# How the code works:
# In theory, each peak is a smooth point spread function (SPF), like a
# Gaussian of some size, etc. In reality, there is always noise, such as
#"salt and pepper" noise, which typically has a 1 pixel variation.
# Because the peak's PSF is assumed to be larger than 1 pixel, the "true"
# local maximum of that PSF can be obtained if we can get rid of these
# single pixel noise variations. There comes medfilt2, which is a 2D median
# filter that gets rid of "salt and pepper" noise. Next we "smooth" the
# image using conv2, so that with high probability there will be only one
# pixel in each peak that will correspond to the "true" PSF local maximum.
# The weighted centroid approach uses the same image processing, with the
# difference that it just calculated the weighted centroid of each
# connected object that was obtained following the image processing.  While
# this gives sub-pixel resolution, it can miss peaks that are very close to
# each other, and runs slightly slower. Read more about how to treat these
# cases in the relevant code commentes.
#
# Inputs:
# d     The 2D data raw image - assumes a Double\Single-precision
#       floating-point, uint8 or unit16 array. Please note that the code
#       casts the raw image to uint16 if needed.  If the image dynamic range
#       is between 0 and 1, I multiplied to fit uint16. This might not be
#       optimal for generic use, so modify according to your needs.
# thres A number between 0 and max(raw_image(:)) to remove  background
# filt  A filter matrix used to smooth the image. The filter size
#       should correspond the characteristic size of the peaks
# edg   A number>1 for skipping the first few and the last few 'edge' pixels
# res   A handle that switches between two peak finding methods:
#       1 - the local maxima method (default).
#       2 - the weighted centroid sub-pixel resolution method.
#       Note that the latter method takes ~20% more time on average.

#Optional Outputs:
# cent        a 1xN vector of coordinates of peaks (x1,y1,x2,y2,...
# [cent cm]   in addition to cent, cm is a binary matrix  of size(d)
#             with 1's for peak positions. (not supported in the
#             the weighted centroid sub-pixel resolution method)
#
#Example:
#
#   p=FastPeakFind(image);
#   imagesc(image); hold on
#   plot(p(1:2:end),p(2:2:end),'r+')
#
#   Adi Natan (natan@stanford.edu)
#   Ver 1.7 , Date: Oct 10th 2013
#




    thres = (maximum([minimum(maximum(d,dims=1))  minimum(maximum(d,dims=2))]));
    edg =3;
#    res = 1;
    mapwindow(median!,d,(3,3))   
#    % apply threshold   
    d=d.*(d.>thres);
    d=imfilter(d, Kernel.gaussian(3));
   # Apply again threshold (and change if needed according to SNR)
    d=d.*(d.>0.35*thres);
        
#        switch res # switch between local maxima and sub-pixel methods
            
#            case 1 # peak find - using the local maxima approach - 1 pixel resolution
                
                # d will be noisy on the edges, and also local maxima looks
                # for nearest neighbors so edge must be at least 1. We'll skip 'edge' pixels.
                
                # initialize outputs
                cent = Array{Int32}(undef, 2, 0)
                image_acc = zeros(Int32,size(d)[1],size(d)[2])

                for i=edg:size(d)[1]-edg
                for j=edg:size(d)[2]-edg
                    if (d[i,j]>=d[i-1,j-1 ])     &&
                            (d[i,j]>d[i-1,j])    &&
                            (d[i,j]>=d[i-1,j+1]) &&
                            (d[i,j]>d[i,j-1])    && 
                            (d[i,j]>d[i,j+1])    && 
                            (d[i,j]>=d[i+1,j-1]) && 
                            (d[i,j]>d[i+1,j])    && 
                            (d[i,j]>=d[i+1,j+1])
                                               
                        cent = cat(dims=2,cent, [i , j]);
                        image_acc[i,j]=1
                    end
                end
    end
                
#            case 2 % find weighted centroids of processed image,  sub-pixel resolution.
#                   % no edg requirement needed.
#                
#                % get peaks areas and centroids
#                stats = regionprops(logical(d),d,'Area','WeightedCentroid');
                
#                % find reliable peaks by considering only peaks with an area
#                % below some limit. The weighted centroid method can be not
#                % accurate if peaks are very close to one another, i.e., a
#                % single peak will be detected, instead of the real number
#                % of peaks. This will result in a much larger area for that
#                % peak. At the moment, the code ignores that peak. If that
#                % happens often consider a different threshold, or return to
#                % the more robust "local maxima" method.
#                % To set a proper limit, inspect your data with:
#                % hist([stats.Area],min([stats.Area]):max([stats.Area]));
#                % to see if the limit I used (mean+2 standard deviations)
#                % is an appropriate limit for your data.
#                
#                rel_peaks_vec=[stats.Area]<=mean([stats.Area])+2*std([stats.Area]);
#                cent=[stats(rel_peaks_vec).WeightedCentroid]';
#                cent_map=[];
        return cent, image_acc;
end
        